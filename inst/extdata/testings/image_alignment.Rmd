---
title: "Image Alignment in R"
editor_options: 
  chunk_output_type: inline
---

# Setup

```{r setup}
if(!requireNamespace("imager", quietly = T)) install.packages("imager")

library(imager)
# library(rcell2.examples)
devtools::load_all()
library(tidyverse)
```

# Tests with imager

- https://cran.r-project.org/web/packages/imager/vignettes/gettingstarted.html
- http://dahtah.github.io/imager/
  - https://dahtah.github.io/imager/imager.html
  - https://dahtah.github.io/imager/morphology.html
  - https://github.com/ShotaOchi/imagerExtra
  - https://cran.r-project.org/web/packages/imagerExtra/vignettes/gettingstarted.html

## Methods

Functions defined in this package:

```{r}
?crop_cimg_around_xy
?fftshift
?cross_correlation
?img_alignment_offset
```

## Data

```{r}
data.dir <-
  "~/Projects/PhD/gitlabs_acl/rtcc/kar4/2024-08-22-RtCC-Ali-5-cepas-y-CFP/data/2024-08-22-RtCC-Ali-5-cepas-y-CFP/renamed/"

# Load two images
frame1 <- file.path(data.dir, "BF_Position01_time02.tif") |> load.image()
frame2 <- file.path(data.dir, "BF_Position01_time04.tif") |> load.image()

x <- 495
y <- 530
w <- 50

# Crop frame1.
img1 <- frame1 |> crop_cimg_around_xy(x, y, w) #|> plot()

# Crop frame2.
img2 <- frame2 |> crop_cimg_around_xy(x, y, w) #|> plot()

# Display the cropped images.
par(mfrow = c(1, 2))
plot(img1, main="Reference")
plot(img2, main="Query")
```

## Test

```{r}
# Calculate the offset through cross-correlation.
xy_offsets <- img_alignment_offset(img1, img2)

# Crop from the original image.
aligned_image <- crop_cimg_around_xy(frame2, x=x-xy_offsets[1], y=y-xy_offsets[2], w=w)

# Align the cropped image.
# aligned_image <- imager::imshift(img2, delta_x = xy_offsets[1], delta_y = xy_offsets[2])
```

```{r}
# Visualize the results
par(mfrow = c(2, 2))
cross_correlation(img1, img2) |> plot()
abline(h=xy_offsets["max_cor_y"], col="red")
abline(v=xy_offsets["max_cor_x"], col="red")
plot(img1, main = "Image 1")
plot(img2, main = "Image 2")
plot(aligned_image, main = "Image 2 (Aligned)")
```

# Tagging cells

The "multi-point" tool in ImageJ can be used to mark cells with different "counters",
by simply clicking on them in the image.

These marks can be exported and mapped back to `ucid`s in R, and then
used for filtering and analysis.

Steps:

1. Open the images in a Hyperstack, as described in the [Preview images using ImageJ] section.
2. Use the multi-point tool to mark individual cells with one or more "counters", as required by your experiment.
3. After tagging the cells, generate the measurements (press `Ctrl+M`) and save
   them to a `.csv` file (press `Ctrl+S`, or `File -> Save`).
  - It is critical that you check that the values of the "Ch" (channel), 
    "Slice", and "Frame" ImageJ measurements map correctly to `t.frame`s,
    `pos`, and `ch` in Cell-IDs output.
  - Note that ImageJ's time indexes begin at 1, but Cell-ID's 
    begin at 0. This may need to be adjusted later.

Detailed instructions on how to import these points and map them to cells 
identified by Cell-ID, can be found in the [Cell-tagging using ImageJ] section
of this notebook.

## Notas sobre el tagueo

1. Taguear celulas CFP en una cepa (6122, delta pho85).
  - Dio razonable. La mejor dosis para cuantificar entre cepas es 1 nM, porque se nota el efecto, y todas las cepas van a estar más a la derecha.
2. Taguear celulas CFP en la dosis de 1 nM, para comprobar que la dosis de feromona efectiva fue homogénea entre wells de la misma columna.
3. Taguear cepas del exp. a 1 nM.
  - *Todas* las células CFP en el well F6 (pos 37 y 38) terminaron **muertas**. No vi esto en el resto de las posiciones, pero tampoco lo busqué.
  - Se ve que las células de esas posiciones tienen una dinamica de switching diferente a la de las demas.

## Load tags

### Tag metadata

```{r}
counter_set1 <- bind_rows(
  data.frame(cell="cfp", Counter = c(0,1,4), tag = c("cell", "bud", "dead")),
  data.frame(cell="exp", Counter = 2:3, tag = c("cell", "bud"))
)

# counter_set1
```

### Control CFP Strain

```{r}
tags_dir <- 
  "~/Projects/PhD/gitlabs_acl/rtcc/kar4/2024-08-22-RtCC-Ali-5-cepas-y-CFP/data/tags"

tags_raw_cfp <- dir(tags_dir, pattern = "*.csv", full.names = T) |> 
  lapply(read.csv) |> 
  bind_rows() |>
  # filter(Counter %in% 1) |>
  left_join(counter_set1,by = join_by(Counter))

# tags_raw_cfp |> 
#   ggplot(aes(X, Y, color = as.factor(Counter))) +
#   geom_point() + 
#   facet_wrap(~Slice) +
#   theme_minimal() + 
#   scale_y_reverse()
```

```{r}
tags_cfp <- tags_raw_cfp |> 
  dplyr::rename(
    pos = Slice,
    t.frame = Frame
  ) |> 
  select(pos, t.frame, cell, tag, X, Y)

# tags_cfp
```

### Experiment Strains

```{r}
tags_raw_exp <- file.path(tags_dir, "exp/") |> dir(pattern = "*.csv", full.names = T) |> 
  lapply(read.csv) |> 
  bind_rows() |>
  filter(Counter %in% 2:3) |>
  left_join(counter_set1,by = join_by(Counter))

# tags_raw_exp |> 
#   ggplot(aes(X, Y, color = as.factor(Counter))) +
#   geom_point() + 
#   facet_wrap(~Slice) +
#   theme_minimal() + 
#   scale_y_reverse()
```


```{r}
tags_exp <- tags_raw_exp |> 
  dplyr::rename(
    pos = Slice,
    t.frame = Frame
  ) |> 
  select(pos, t.frame, cell, tag, X, Y)

# tags_exp
```

### Combine tags

```{r}
all_buds <- bind_rows(tags_cfp,tags_exp) |> 
  filter(tag == "bud")

all_buds
```


# Inspect cells

## Get image paths

```{r}
images <- rcell2.cellid::arguments(data.dir) |> 
  rcell2.cellid::arguments_to_images()

images$t.frame |> range()
```

## Preview cells

```{r}
cdata <- all_buds |> 
  filter(t.frame > 3) |> 
  # mutate(t.frame = min(t.frame + 1, 65)) |> 
  dplyr::rename(xpos=X, ypos=Y) |> 
  mutate(ucid=1:n())

cdata |> nrow()

rcell2.magick::magickCell(cdata, images, annotation_params = NULL,
                          ch = "TFP", normalize_images = T, boxSize = 40, cell_resize = 100) |> 
  rcell2.magick::magickForKnitr()
```

Reframe cdata to obtain adjacent frames for cell strips:

```{r}
# Transform each group to an arbitrary number of rows
cdata_adj <- cdata |> group_by(pos, ucid) |> 
  # Expand frames around the bud, from the beggining of the experiment.
  reframe(t.frame = 1:(t.frame+1)) |> 
  # Keep only valid frames that exist.
  semi_join(images) |> 
  # Keep only sequences of sufficient length.
  group_by(ucid) |> 
  filter(n() >= 3) |> 
  # Reinsert the data.
  left_join(
    cdata |> rename(t.bud = t.frame)
  )

cdata_adj |> 
  ggplot() + geom_tile(aes(t.frame, ucid))
```

```{r}
cdata_adj |> 
  rcell2.magick::cellStrips(images, n_ucids = 5, ch = "TFP",
                            annotation_params = NULL,
                            normalize_images = T, boxSize = 40, cell_resize = 100
                            ) |> 
  magick::image_join() |> 
  magick::image_append(stack = T) |> 
  rcell2.magick::magickForKnitr()
```

## Align two images

Sample:

```{r}
d <- cdata_adj |> split(~ucid) |> sample(1) |> first()

t.bud <- d$t.bud[1]

xy <- d |> filter(t.bud == t.frame) |> with(c(xpos, ypos))

i <- images |> semi_join(d) |> 
  filter(channel == "TFP")
```

Process:

```{r}
# Set reference frame.
t.start <- t.bud
# Get query frame.
t.next <- d |> 
  filter(t.frame != t.start) |> 
  filter(t.frame == t.frame[ which.min(abs(t.frame - t.start)) ]) |> 
  with(t.frame)
# Get image paths.
path1 <- i |> filter(t.frame == t.start) |> with(file)
path2 <- i |> filter(t.frame == t.next) |> with(file)
```


```{r}
# Load two images
frame1 <- load.image(path1)
frame2 <- load.image(path2)

# Set crop size.
w <- 50

# Crop frame1.
img1 <- frame1 |> crop_cimg_around_xy(xy[1], xy[2], w)
# Crop frame2.
img2 <- frame2 |> crop_cimg_around_xy(xy[1], xy[2], w)

# Display the cropped images.
par(mfrow = c(1, 2))
plot(img1, main="Reference")
abline(h=51/2, col="red")
abline(v=51/2, col="red")
plot(img2, main="Query")
abline(h=51/2, col="red")
abline(v=51/2, col="red")
```

```{r}
devtools::load_all()
```


```{r}
# Calculate the offset through cross-correlation.
xy_offsets <- img_alignment_offset(img1, img2)

# Crop from the original image.
aligned_image <- crop_cimg_around_xy(frame2, x=xy[1]-xy_offsets[1], y=xy[2]-xy_offsets[2], w=w)
```

```{r}
# Visualize the results
par(mfrow = c(2, 2))
cross_correlation(img1, img2) |> plot()
abline(h=xy_offsets["max_cor_y"], col="red")
abline(v=xy_offsets["max_cor_x"], col="red")
plot(img1, main = "Image 1")
abline(h=51/2, col="red")
abline(v=51/2, col="red")
plot(img2, main = "Image 2")
abline(h=51/2, col="red")
abline(v=51/2, col="red")
plot(aligned_image, main = "Image 2 (Aligned)")
abline(h=51/2, col="red")
abline(v=51/2, col="red")
```


```{r}
m <- cross_correlation(img1, img2) |>
  as.matrix()

m_df <- m |> t() |> 
  utiles::matrix_to_df()

m_df |> 
  ggplot(aes(x,y)) +
  geom_tile(aes(fill=pix_value)) +
  geom_tile(fill="red", data=m_df |> filter(pix_value == max(pix_value))) +
  geom_hline(yintercept=xy_offsets["max_cor_y"], alpha = .5, color="red") +
  geom_vline(xintercept=xy_offsets["max_cor_x"], alpha = .5, color="red") +
  geom_hline(yintercept=round(51/2), alpha = .5, linetype=2) +
  geom_vline(xintercept=round(51/2), alpha = .5, linetype=2) +
  coord_equal() +
  theme_minimal()
```







