---
title: "Image Alignment in R"
editor_options: 
  chunk_output_type: inline
---

# Install imager

```{r setup}
if(!requireNamespace("imager", quietly = T)) install.packages("imager")

library(imager)
```

# Tests with imager

- https://cran.r-project.org/web/packages/imager/vignettes/gettingstarted.html
- http://dahtah.github.io/imager/
  - https://dahtah.github.io/imager/imager.html
  - https://dahtah.github.io/imager/morphology.html
  - https://github.com/ShotaOchi/imagerExtra
  - https://cran.r-project.org/web/packages/imagerExtra/vignettes/gettingstarted.html

## Methods

```{r}
crop_cimg_around_xy <- function(img, x, y, w=50){
  
  # Define cropping coordinates
  x_min <- x - w/2 |> floor()
  x_max <- x + w/2 |> ceiling()
  y_min <- y - w/2 |> floor()
  y_max <- y + w/2 |> ceiling()
  
  # Crop the image
  cropped_img <- img[x_min:x_max, y_min:y_max,, ] |> 
    as.cimg()
  
  return(cropped_img)
}
```

Define a function to shift zero-frequency component to the center of the spectrum.

- http://matlab.izmiran.ru/help/techdoc/ref/fftshift.html
- https://stackoverflow.com/a/49863001

>  FFTSHIFT shifts the zero-frequency component to the center of the signal.
> In this case the signal is an image. A good visual guide is this.
> If you expand the original output image, you will see something akin to this:

```{r}
# Define a function to shift zero-frequency component to center.
# Esto fue importante para poder encontrar consistentemente el máximo de la 
# correlacion cruzada cerca del centro si el offset es pequeño.
fftshift <- function(x) {
  # Shift the zero-frequency component to the center of the spectrum
  n <- length(x)
  return(c(x[(n/2 + 1):n], x[1:(n/2)]))
}
```

FFT Based Cross Correlation Computations

- http://www.learnpiv.org/fft/
- https://chatgpt.com/share/674f5516-bb78-800f-9038-e00152429327

```{r}
# Define a function for cross-correlation
cross_correlation <- function(img1, img2) {
  # Ensure both images are matrices of the same size
  if (!all(dim(img1) == dim(img2))) {
    stop("Images must have the same dimensions for cross-correlation.")
  }
  
  # Compute cross-correlation using fft (fast Fourier transform)
  # Step 1: Compute FFT of both images
  fft1 <- fft(img1)
  fft2 <- fft(img2)
  
  # Step 2: Element-wise multiplication of one FFT with the conjugate of the other
  fft_cross <- fft1 * Conj(fft2)
  
  # Step 3: Inverse FFT to get cross-correlation
  cross_corr <- Re(fft(fft_cross, inverse = TRUE))
  
  # Step 4: Apply fftshift to center the zero-frequency component
  cross_corr_shift <- fftshift(cross_corr)
  
  # Convert back to a cimg object.
  cross_corr_shift_img <- cross_corr_shift |>
    array(dim(cross_corr)) |> 
    as.cimg()
  
  # Normalize the result
  cross_corr_norm <- cross_corr_shift_img / max(abs(cross_corr_shift))
  
  return(cross_corr_norm)
}
```

```{r}
img_alignment_offset <- function(img1, img2){
  # Compute cross-correlation
  cross_corr <- cross_correlation(img1, img2)
  dim(img1)
  dim(cross_corr)
  
  # Display the result
  # result |> as.cimg() |> plot()
  # image(cross_corr[,,1,], main = "Cross-Correlation", col = heat.colors(256))
  
  max_index <- which(cross_corr == max(cross_corr), arr.ind = TRUE) 
  
  # # Subtract the center of the image, because the correlation matrix may be double
  # # the size of the input image (padded to compute the correlation).
  # offset_y <- max_index[1] - nrow(img1) / 2
  # offset_x <- max_index[2] - ncol(img1) / 2
  # 
  # # Shift the second image to align with the first
  # aligned_image <- imager::imshift(img2, x = -offset_x, y = -offset_y)
  
  f <- function(o, d) if(o > d) {o - d} else {o + d}
  
  offsets <- max_index[1:2] %% dim(img1)[1:2] - 1
  offset_x <- offsets[1] - dim(img1)[1] / 2
  offset_y <- offsets[2] - dim(img1)[2] / 2
  cat("Offset X:", offset_x, "Offset Y:", offset_y, "\n")
  
  return(
    c(offset_x=offset_x,offset_y=offset_y)
  )
}
```

## Data

```{r}
data.dir <-
  "~/Projects/PhD/gitlabs_acl/rtcc/kar4/2024-08-22-RtCC-Ali-5-cepas-y-CFP/data/2024-08-22-RtCC-Ali-5-cepas-y-CFP/renamed/"

# Load two images
frame1 <- file.path(data.dir, "BF_Position01_time02.tif") |> load.image()
frame2 <- file.path(data.dir, "BF_Position01_time04.tif") |> load.image()

x <- 495
y <- 530
w <- 50

# Crop frame1.
img1 <- frame1 |> crop_cimg_around_xy(x, y, w) #|> plot()

# Crop frame2.
# img2 <- frame2 |> crop_cimg_around_xy(x-5, y+10, w) #|> plot()
img2 <- frame2 |> crop_cimg_around_xy(x, y, w) #|> plot()
```


## Test

```{r}
# Display the cropped image
# img2 <- frame1 |> crop_cimg_around_xy(x+5, y-10, w) #|> plot()
# img2 <- frame1 |> crop_cimg_around_xy(x, y, w) #|> plot()
# par(mfrow = c(1, 2))
# plot(img1)
# plot(img2)

# Calculate the offset through cross-correlation.
xy_offsets <- img_alignment_offset(img1, img2)

# Align the image.
aligned_image <- crop_cimg_around_xy(frame2, x=x-xy_offsets[1], y=y-xy_offsets[2], w=w)
# aligned_image <- imager::imshift(img2, delta_x = xy_offsets[1], delta_y = xy_offsets[2])

# Visualize the results
par(mfrow = c(2, 2))
cross_corr |> plot()
abline(h=offsets[2], col="red")
abline(v=offsets[1], col="red")
plot(img1, main = "Image 1")
plot(img2, main = "Image 2")
plot(aligned_image, main = "Image 2 (Aligned)")
```

# Tagging cells

The "multi-point" tool in ImageJ can be used to mark cells with different "counters",
by simply clicking on them in the image.

These marks can be exported and mapped back to `ucid`s in R, and then
used for filtering and analysis.

Steps:

1. Open the images in a Hyperstack, as described in the [Preview images using ImageJ] section.
2. Use the multi-point tool to mark individual cells with one or more "counters", as required by your experiment.
3. After tagging the cells, generate the measurements (press `Ctrl+M`) and save
   them to a `.csv` file (press `Ctrl+S`, or `File -> Save`).
  - It is critical that you check that the values of the "Ch" (channel), 
    "Slice", and "Frame" ImageJ measurements map correctly to `t.frame`s,
    `pos`, and `ch` in Cell-IDs output.
  - Note that ImageJ's time indexes begin at 1, but Cell-ID's 
    begin at 0. This may need to be adjusted later.

Detailed instructions on how to import these points and map them to cells 
identified by Cell-ID, can be found in the [Cell-tagging using ImageJ] section
of this notebook.

##### Notas sobre el tagueo

1. Taguear celulas CFP en una cepa (6122, delta pho85).
  - Dio razonable. La mejor dosis para cuantificar entre cepas es 1 nM, porque se nota el efecto, y todas las cepas van a estar más a la derecha.
2. Taguear celulas CFP en la dosis de 1 nM, para comprobar que la dosis de feromona efectiva fue homogénea entre wells de la misma columna.
3. Taguear cepas del exp. a 1 nM.
  - *Todas* las células CFP en el well F6 (pos 37 y 38) terminaron **muertas**. No vi esto en el resto de las posiciones, pero tampoco lo busqué.
  - Se ve que las células de esas posiciones tienen una dinamica de switching diferente a la de las demas.

##### Counter metadata

```{r}
counter_set1 <- bind_rows(
  data.frame(cell="cfp", Counter = c(0,1,4), tag = c("cell", "bud", "dead")),
  data.frame(cell="exp", Counter = 2:3, tag = c("cell", "bud"))
)

counter_set1
```

##### CFP Strain

```{r}
tags_dir <- 
  "~/Projects/PhD/gitlabs_acl/rtcc/kar4/2024-08-22-RtCC-Ali-5-cepas-y-CFP/data/tags"

tags_raw_cfp <- dir(tags_dir, pattern = "*.csv", full.names = T) |> 
  lapply(read.csv) |> 
  bind_rows() |>
  # filter(Counter %in% 1) |>
  left_join(counter_set1)

tags_raw_cfp |> 
  ggplot(aes(X, Y, color = as.factor(Counter))) +
  geom_point() + 
  facet_wrap(~Slice) +
  theme_minimal() + 
  scale_y_reverse()
```

```{r}
tags_cfp <- tags_raw_cfp |> 
  dplyr::rename(
    pos = Slice,
    t.frame = Frame
  ) |> 
  select(pos, t.frame, cell, tag)

tags_cfp
```

###### Plot distributions

```{r}
data_cfp <- tags_cfp |> 
  filter(tag == "bud") |> 
  filter(cell == "cfp") |> 
  left_join(pdata) |> 
  group_by(pheromone) |> 
  mutate(replica = pos |> as.factor() |> as.integer())
```

```{r}
p0 <- data_cfp |> 
  ggplot() + 
  
  # geom_density(aes(x=t.frame, color=interaction(row, col, sep = ""))) +
  geom_density(aes(x=t.frame, y=..scaled.., color=as.ordered(pheromone)), size=2) +
  # geom_histogram(aes(x=t.frame, y=..count../sum(..count..), fill=interaction(row, col, sep = "")), binwidth = 7) +
  
  # facet_wrap(~pheromone, scales = "free_y") +
  facet_grid(strain~pheromone, scales = "free_y") +
  
  # geom_density(aes(x=t.frame, y=..scaled.., color=as.ordered(pheromone)), size=2) +
  # geom_density(aes(x=t.frame, y=..scaled.., fill=as.ordered(pheromone)), alpha=.2) +
  # scale_fill_discrete() +
  
  labs(color="dose") +
  theme_minimal() +
  ggtitle("CFP cell reentry times")

p0
```

```{r}
# ggsave("plots/dist_raw.png", p0)
```


```{r}
p0.1 <- data_cfp |>
  # filter(t.frame > 2) |> 

  ggplot() + 
  
  # geom_density(aes(x=t.frame, color=interaction(row, col, sep = ""))) +
  # geom_density(aes(x=t.frame, y=..scaled.., color=as.ordered(pheromone)), size=2) +
  # geom_histogram(aes(x=t.frame, y=..count../sum(..count..), fill=interaction(row, col, sep = "")), binwidth = 7) +
  geom_histogram(aes(x=t.frame, fill=as.ordered(pheromone)), binwidth = 4) +
  
  geom_text(aes(label=pos), x=40, y=20,
            data = data_cfp |> group_by(strain, pheromone) |> summarise(pos = paste(unique(pos), collapse=", "))
            ) +
  
  # facet_wrap(~pheromone, scales = "free_y") +
  # facet_grid(strain~pheromone, scales = "free_y") +
  facet_grid(strain~pheromone) +
  # facet_grid(row~col, scales = "free_y") +
  
  # geom_density(aes(x=t.frame, y=..scaled.., color=as.ordered(pheromone)), size=2) +
  # geom_density(aes(x=t.frame, y=..scaled.., fill=as.ordered(pheromone)), alpha=.2) +
  # scale_fill_discrete() +
  
  labs(color="dose", fill="dose") +
  theme_minimal() +
  ggtitle("CFP cell reentry times")

p0.1
```

###### Cumulative RtCC

```{r}
bud_counts_cfp <- tags_cfp |>
  # Keep budding events
  filter(tag == "bud") |> 
  # Keep CFP cells
  filter(cell == "cfp") |> 
  # Join pdata
  left_join(pdata, by = "pos") |> 
  # Add replica column
  group_by(pheromone) |> 
  mutate(well = interaction(row, col)) |> 
  ungroup() |> 
  # Generate comulative counts.
  group_by(strain, pheromone, well, t.frame) |> 
  summarise(count = n()) |> 
  arrange(pheromone, t.frame) |> 
  mutate(cum_sum=cumsum(count))
```


```{r}
p1.1 <- bud_counts_cfp |> 
  ggplot() +
  geom_line(aes(t.frame, cum_sum, group=well, color=as.ordered(well)), size=2) +
  theme_minimal() +
  ggtitle("Cumulative sum of budding events", "Raw counts")

p1.1

p1.1 + facet_wrap(~pheromone)

# p1.2 <- bud_counts_cfp |>
#   mutate(cum_sum_basal05=cum_sum-quantile(cum_sum, 0.05)) |>
#   ggplot() +
#   geom_line(aes(t.frame, cum_sum_basal05, color=well)) +
#   facet_wrap(~pheromone) +
#   theme_minimal()
# 
# p1.2
```

```{r}
# ggsave("plots/cumul_raw.png", p1.1)
```

```{r}
cell_counts_cfp <- tags_cfp |> 
  # Join pdata
  left_join(pdata, by = "pos") |> 
  # Keep cell counts
  filter(tag == "cell") |> 
  # Keep CFP cells
  filter(cell == "cfp") |> 
  # Add replica column
  group_by(pheromone) |> 
  mutate(well = interaction(row, col)) |> 
  ungroup() |>
  # Count cells by well
  group_by(well) |> 
  summarise(n_init=n()) |> 
  # Keep only metadata
  select(well, n_init)

rel_bud_counts_cfp <- bud_counts_cfp |> 
  # Add cell counts
  left_join(cell_counts_cfp) |> 
  # Normalize sum.
  mutate(rel_sum = cum_sum/n_init) |> 
  # Subtract initial value.
  group_by(well) |> 
  mutate(rel_sum_0 = rel_sum - min(rel_sum))
```


```{r}
p2.1 <- rel_bud_counts_cfp |> 
  # Plot
  ggplot() +
  geom_line(aes(t.frame, rel_sum, color=well)) +
  facet_grid(pheromone~.) +
  ggtitle("Cumulative sum of budding events", "Normalized to initial cell count") +
  theme_minimal()

p2.1

p2.2 <- rel_bud_counts_cfp |> 
  # Plot
  ggplot() +
  geom_line(aes(t.frame, rel_sum, color=as.factor(pheromone), group=well), size=5, alpha=.75) +
  ggtitle("Cumulative sum of budding events", "Normalized to initial cell count") +
  theme_minimal() +
  labs(color="pheromone")

p2.2

p2.3 <- rel_bud_counts_cfp |> 
  # Plot
  ggplot() +
  geom_line(aes(t.frame, rel_sum, color=as.factor(well), group=well), size=2, alpha=.85) +
  ggtitle("Cumulative sum of budding events", "Normalized to initial cell count") +
  theme_minimal() +
  facet_wrap(~pheromone) +
  labs(color="pheromone")

p2.3
```

```{r}
# ggsave("plots/cumul_rel.png", p2.1)
# ggsave("plots/cumul_rel-stacked.png", p2.2)
```


##### Experiment Strains

```{r}
tags_raw_exp <- dir("data/tags/exp/", pattern = "*.csv", full.names = T) |> 
  lapply(read.csv) |> 
  bind_rows() |>
  filter(Counter %in% 2:3) |>
  left_join(counter_set1)
```


```{r}
tags_raw_exp |> 
  ggplot(aes(X, Y, color = as.factor(Counter))) +
  geom_point() + 
  facet_wrap(~Slice) +
  theme_minimal() + 
  scale_y_reverse()
```


```{r}
tags_exp <- tags_raw_exp |> 
  dplyr::rename(
    pos = Slice,
    t.frame = Frame
  ) |> 
  select(pos, t.frame, cell, tag)

# tags_exp
```

###### Plot distributions

```{r}
data_exp <- tags_exp |> 
  filter(tag == "bud") |> 
  filter(cell == "exp") |> 
  left_join(pdata) |> 
  group_by(pheromone) |> 
  mutate(replica = pos |> as.factor() |> as.integer())
```


```{r}
p0_exp <- data_exp |> 
  ggplot() + 
  
  # geom_density(aes(x=t.frame, color=interaction(row, col, sep = ""))) +
  geom_density(aes(x=t.frame, y=..scaled.., color=as.ordered(pheromone)), size=2) +
  # geom_histogram(aes(x=t.frame, y=..count../sum(..count..), fill=interaction(row, col, sep = "")), binwidth = 7) +
  
  # facet_wrap(~pheromone, scales = "free_y") +
  facet_grid(strain~pheromone, scales = "free_y") +
  
  # geom_density(aes(x=t.frame, y=..scaled.., color=as.ordered(pheromone)), size=2) +
  # geom_density(aes(x=t.frame, y=..scaled.., fill=as.ordered(pheromone)), alpha=.2) +
  # scale_fill_discrete() +
  
  labs(color="dose") +
  theme_minimal() +
  ggtitle("Exp. cell reentry times")

p0_exp
```

```{r}
pos_names <- data_exp |> group_by(genotype2, strain, pheromone) |> summarise(pos = paste(unique(pos), collapse=", "))
p0.1_exp <- data_exp |>
  # filter(t.frame > 2) |> 

  ggplot() + 
  
  # geom_density(aes(x=t.frame, color=interaction(row, col, sep = ""))) +
  # geom_density(aes(x=t.frame, y=..scaled.., color=as.ordered(pheromone)), size=2) +
  # geom_histogram(aes(x=t.frame, y=..count../sum(..count..), fill=interaction(row, col, sep = "")), binwidth = 7) +
  geom_histogram(aes(x=t.frame, fill=as.ordered(pheromone)), binwidth = 4) +
  
  geom_text(aes(label=pos), x=40, y=20, data = pos_names) +
  
  # facet_wrap(~pheromone, scales = "free_y") +
  # facet_grid(strain~pheromone, scales = "free_y") +
  # facet_grid(strain~pheromone) +
  # facet_grid(row~col, scales = "free_y") +
  
  facet_grid(genotype2~pheromone) +
  
  # geom_density(aes(x=t.frame, y=..scaled.., color=as.ordered(pheromone)), size=2) +
  # geom_density(aes(x=t.frame, y=..scaled.., fill=as.ordered(pheromone)), alpha=.2) +
  # scale_fill_discrete() +
  
  labs(color="dose", fill="dose") +
  theme_minimal() +
  ggtitle("Exp. cell reentry times")

p0.1_exp
```

```{r}
pos_names <- data_exp |> group_by(row, col) |> summarise(pos = paste(unique(pos), collapse=", "))
p0.1_exp_colrow <- data_exp |>
  ggplot() + 
  geom_histogram(aes(x=t.frame, fill=as.ordered(pheromone)), binwidth = 4) +
  geom_text(aes(label=pos), x=40, y=20, data = pos_names) +
  facet_grid(row~col) +
  labs(color="dose", fill="dose") +
  theme_minimal() +
  ggtitle("Exp. cell reentry times")

p0.1_exp_colrow
```

###### Cumulative RtCC

```{r}
bud_counts_exp <- tags_exp |>
  # Keep budding events
  filter(tag == "bud") |> 
  # Keep EXP cells
  filter(cell == "exp") |> 
  # Join pdata
  left_join(pdata, by = "pos") |> 
  # Add replica column
  group_by(pheromone) |> 
  mutate(well = interaction(row, col, sep = "")) |> 
  ungroup() |> 
  # Generate cumulative counts.
  group_by(strain, pheromone, well, t.frame) |> 
  summarise(count = n()) |> 
  arrange(pheromone, t.frame) |> 
  mutate(cum_sum=cumsum(count))
```


```{r}
p1.1_exp <- bud_counts_exp |>
  ggplot() +
  geom_line(aes(t.frame, cum_sum, group=well, color=as.ordered(well)), size=2) +
  theme_minimal() +
  ggtitle("Cumulative sum of budding events", "Raw counts")

p1.1_exp

p1.1_exp + facet_wrap(~pheromone)

# p1.2_exp <- bud_counts |>
#   mutate(cum_sum_basal05=cum_sum-quantile(cum_sum, 0.05)) |>
#   ggplot() +
#   geom_line(aes(t.frame, cum_sum_basal05, color=well)) +
#   facet_wrap(~pheromone) +
#   theme_minimal()
# 
# p1.2_exp
```

```{r}
cell_counts_exp <- tags_exp |> 
  # Join pdata
  left_join(pdata, by = "pos") |> 
  # Keep cell counts
  filter(tag == "cell") |> 
  # Keep CFP cells
  filter(cell == "exp") |> 
  
  # Add replica column
  # group_by(pheromone) |> 
  mutate(well = interaction(row, col, sep = "")) |> 
  # ungroup() |>
  
  # Count cells by well
  group_by(well) |> 
  summarise(n_init=n()) |> 
  # Keep only metadata
  select(well, n_init)

rel_bud_counts_exp <- bud_counts_exp |> 
  # Add cell counts
  left_join(cell_counts_exp) |> 
  # Normalize sum.
  mutate(rel_sum = cum_sum/n_init)

rel_bud_counts_exp
```


```{r}
p2.1_exp <- rel_bud_counts_exp |> 
  # Plot
  ggplot() +
  geom_line(aes(t.frame, rel_sum, color=well)) +
  facet_grid(pheromone~.) +
  ggtitle("Cumulative sum of budding events", "Normalized to initial cell count") +
  theme_minimal()

p2.1_exp

p2.2_exp <- rel_bud_counts_exp |> 
  # Plot
  ggplot() +
  geom_line(aes(t.frame, rel_sum, color=as.factor(pheromone), group=well), size=5, alpha=.75) +
  ggtitle("Cumulative sum of budding events", "Normalized to initial cell count") +
  theme_minimal() +
  labs(color="pheromone")

p2.2_exp

p2.3_exp <- rel_bud_counts_exp |> 
  # Plot
  ggplot() +
  geom_line(aes(t.frame, rel_sum, color=as.factor(well), group=well), size=3, alpha=.75) +
  ggtitle("Cumulative sum of budding events", "Normalized to initial cell count") +
  theme_minimal() +
  facet_wrap(~pheromone) +
  labs(color="pheromone")

p2.3_exp
```

```{r}
approx_5 <- function(t.frame, rel_sum, na_value=10){
  # y <- approx(x=t.frame, y=rel_sum, xout = 5, rule = 2)$y
  y <- approx(x=t.frame, y=rel_sum, xout = 5)$y
  # return( if(is.na(y)) na_value else y )
  return( y )
}
```


```{r}
# d <- rel_bud_counts_exp |> 
#   left_join(genotypes) |> 
#   filter(pheromone == 10, genotype2 == "ΔKar4")
# 
# approx_5(t.frame = d$t.frame, rel_sum = d$rel_sum)
```


```{r}
rel_bud_counts_exp_0 <- rel_bud_counts_exp |> 
  # Keep only cells after the 3rd frame.
  filter(t.frame > 0) |> 
  # Subtract initial value.
  group_by(well) |> 
  mutate(rel_sum_5 = rel_sum - approx_5(t.frame, rel_sum),
         rel_sum_0 = rel_sum - min(rel_sum)) |> 
  # Nice names for strains
  left_join(genotypes)
```


```{r}
p2.4_exp <- rel_bud_counts_exp_0 |> 
  # Plot
  ggplot() +
  geom_point(aes(t.frame, rel_sum_0, color=as.factor(genotype2), group=well), size=1) +
  geom_line(aes(t.frame, rel_sum_0, color=as.factor(genotype2), group=well), size=.2, alpha=.85) +
  ggtitle("Cumulative sum of budding events", "Relative to total cell count, centered by value at t=1.") +
  theme_minimal() +
  # facet_grid(~pheromone) +
  facet_wrap(~pheromone, scales = "free") +
  labs(color="genotype")

p2.4_exp

p2.4_exp_5 <- rel_bud_counts_exp_0 |> 
  # Plot
  ggplot() +
  geom_point(aes(t.frame, rel_sum_5, color=as.factor(genotype2), group=well), size=2) +
  geom_line(aes(t.frame, rel_sum_5, color=as.factor(genotype2), group=well), size=.2, alpha=.85) +
  ggtitle("Cumulative sum of budding events", "Relative to total cell count, centered by value at t=5.") +
  theme_minimal() +
  # facet_grid(~pheromone) +
  facet_wrap(~pheromone, scales = "free") +
  labs(color="genotype") +
  theme(legend.position = "top")

p2.4_exp_5
```

```{r}
# ggsave("plots/p2.4_exp_5.jpg", p2.4_exp_5)
```


```{r}
rel_bud_counts_cfp_0 <- rel_bud_counts_cfp |> 
  # Keep only cells after the 3rd frame.
  filter(t.frame > 0) |> 
  # Keep only the common strains.
  filter(strain %in% unique(rel_bud_counts_exp_0$strain)) |> 
  # Subtract initial value.
  group_by(well) |> 
  mutate(rel_sum_5 = rel_sum - approx_5(t.frame, rel_sum),
         rel_sum_0 = rel_sum - min(rel_sum)) |> 
  # Nice names for strains
  left_join(genotypes)
```


```{r}
p2.4_cfp <- rel_bud_counts_cfp_0 |> 
  left_join(genotypes) |> 

  # Plot
  ggplot() +
  geom_point(aes(t.frame, rel_sum_5, color=as.factor(genotype2), group=well), size=2) +
  geom_line(aes(t.frame, rel_sum_5, color=as.factor(genotype2), group=well), size=.2, alpha=.85) +
  ggtitle("Cumulative sum of budding events of CFP cells", "Normalized to initial cell count") +
  theme_minimal() +
  # facet_grid(~pheromone) +
  facet_wrap(~pheromone, scales = "free") +
  labs(color="genotype")+
  theme(legend.position = "top")

p2.4_cfp
```

##### Mixture model

###### Model fit function

```{r}
fit <- function(x, family = "normal"){
  
  if(family == "normal"){
    out_cols <- c("pi", "mu", "sd")
  } else if(family == "gamma"){
    out_cols <- c("pi", "mu", "sd", "alpha", "lambda")
  } else {
    stop("Unsupported distribution family name.")
  }
  
  # Get the data
  # x <- d$t.frame
  # x <- c(d$t.frame, d$t.frame)
  # Selecting the best g for Normal mixture model
  
  s_normal <- mixR::select(x, ncomp = 1:2, family = family, max_iter = 50)
  # plot(s_normal)
  
  # Get the index of the best model.
  # which_best <- which(s_normal$best == "*")
  if(family == "normal"){
    which_best <- s_normal |> lapply(c) |> as.data.frame() |> 
      mutate(id = 1:n()) |> 
      filter(equal.var == "N") |>
      filter(bic == min(bic, na.rm = T)) |> 
      with(id)
  } else {
    which_best <- s_normal |> lapply(c) |> as.data.frame() |> 
      mutate(id = 1:n()) |> 
      filter(bic == min(bic, na.rm = T)) |> 
      with(id)
  }
  # Get the number of components of the best model.
  ncomp = s_normal$ncomp[which_best]
  # Get the variance equality (?) of the best model.
  equal_var = s_normal$equal.var[which_best]
  
  # Re-fit the model.
  mod_normal <- mixR::mixfit(x = x, ncomp = ncomp, family = family)
  
  if(is.null(mod_normal)) return(NULL)
  
  # Get the main parameters.    
  # pi: a numeric vector representing the estimated proportion of each component
  # mu: a numeric vector representing the estimated mean of each component
  # sd: a numeric vector representing the estimated standard deviation of each component
  parameters <- mod_normal[out_cols] |> 
    as.data.frame() |> 
    mutate(comp = 1:ncomp) |> 
    mutate(status = "ok")

  return(parameters)
}
```

###### Exp. cells

```{r}
p0.1_exp
```

```{r}
data_exp_p1 <- data_exp |>
  # filter(pheromone == 1) |> 
  filter(cell == "exp", tag == "bud")

s <- data_exp_p1 |> split(~strain+pheromone, sep = "-")
# s[[2]]

family = "normal"
family = "gamma"
```

```{r}
mix_model_exp_p1 <- s |> 
  seq_along() |>
  lapply(function(i){
    d <- s[[i]]
    r <- tryCatch(
      {
        suppressMessages(suppressWarnings(
          fit(d$t.frame, family = family) |> 
            mutate(pos = d$pos[1])
        ))
      }, 
      error = function(e) return(data.frame(status = e$message, pos = d$pos[1]))
    )
    print(paste(i, d$pos[1], r$pos[1], r$status[1]))
    return(r)
  }) |> 
  bind_rows() |>
  filter(status == "ok") |>
  left_join(pdata)

mix_model_exp_p1
```

```{r}
pos_names <- data_exp |> left_join(genotypes) |> group_by(genotype2, pheromone) |> summarise(pos = paste(unique(pos), collapse=", "))
p0.1_exp_fit <- data_exp |> 

  ggplot() + 
  
  geom_histogram(aes(x=t.frame, fill=as.ordered(pheromone)), binwidth = 4) +
  
  geom_vline(aes(xintercept = mu), data = mix_model_exp_p1) +
  geom_vline(aes(xintercept = mu, size = sd), data = mix_model_exp_p1, alpha = .2) +
  
  geom_label(aes(label=paste("pos", pos)), x=40, y=40, size = 3, data = pos_names) +
  
  facet_grid(genotype2~pheromone) +
  
  labs(color="dose", fill="dose") + guides(size="none") +
  theme_minimal() +
  ggtitle("Exp. cell reentry times")

p0.1_exp_fit
```

```{r}
# ggsave("plots/p0.1_exp_fit.jpg", p0.1_exp_fit)
```

```{r}
pos_names <- data_exp |> left_join(genotypes) |> group_by(genotype2, pheromone) |> summarise(pos = paste(unique(pos), collapse=", "))
p0.1_exp_fit_plt5 <- data_exp |> filter(pheromone <= 5) |> 

  ggplot() + 
  
  geom_histogram(aes(x=t.frame, fill=as.ordered(pheromone)), binwidth = 4) +
  
  geom_vline(aes(xintercept = mu), data = mix_model_exp_p1 |> filter(pheromone <= 5)) +
  geom_vline(aes(xintercept = mu, size = sd), data = mix_model_exp_p1 |> filter(pheromone <= 5), alpha = .2) +
  
  # geom_label(aes(label=paste("pos", pos)), x=40, y=40, size = 3, data = pos_names |> filter(pheromone <= 5)) +
  
  facet_grid(genotype2~pheromone) +
  
  labs(color="dose", fill="dose") + guides(size="none") +
  theme_minimal() +
  ggtitle("Exp. cell reentry times", "(pheromone <= 5 only)")

p0.1_exp_fit_plt5
```

###### CFP cells

```{r}
p0.1
```


```{r}
data_cfp_p1 <- data_cfp |>
  # filter(pheromone == 1) |> 
  filter(cell == "cfp", tag == "bud") |> 
  filter(strain != 3154)

data_cfp_p1_split <- data_cfp_p1 |> split(~genotype2+pheromone, sep = "-")

# sapply(data_cfp_p1_split, nrow) |> sort()
```


```{r}
# i <- 1
mix_model_cfp_p1 <- data_cfp_p1_split |> 
  seq_along() |>
  lapply(function(i){
    # print(i)
    d <- data_cfp_p1_split[[i]]
    r <- tryCatch(
      {
        suppressMessages(suppressWarnings(
          fit(d$t.frame, family = family) |> 
            mutate(pos = d$pos[1])
        ))      }, error = function(e){
        return(data.frame(status = e$message, pos = d$pos[1]))
      }
    )
    return(r)
  }) |> 
  bind_rows() |>
  filter(status == "ok") |>
  left_join(pdata)

mix_model_cfp_p1
```

```{r}
pos_names <- data_cfp_p1 |> left_join(genotypes) |> group_by(genotype2, pheromone) |> summarise(pos = paste(unique(pos), collapse=", "))
p0.1_cfp_fit <- data_cfp_p1 |> 

  ggplot() + 
  
  geom_histogram(aes(x=t.frame, fill=as.ordered(pheromone)), binwidth = 4) +
  
  geom_vline(aes(xintercept = mu), data = mix_model_cfp_p1) +
  geom_vline(aes(xintercept = mu, size = sd), data = mix_model_cfp_p1, alpha = .2) +
  
  geom_label(aes(label=paste("pos", pos)), x=40, y=25, size = 3, data = pos_names) +
  
  facet_grid(genotype2~pheromone) +
  
  labs(color="dose", fill="dose") + guides(size="none") +
  theme_minimal() +
  ggtitle("CFP cell reentry times")

p0.1_cfp_fit
```

```{r}
p0.1_exp_fit
```


```{r}
pheromone_proxy <- mix_model_cfp_p1 |> 
  group_by(row, col) |> 
  filter(n() == 2) |> 
  filter(mu == max(mu)) |> 
  select(mu, row, col) |> 
  dplyr::rename(pheromone_proxy = mu)

pheromone_proxy
```


```{r}
d_proxy <- mix_model_exp_p1 |> 
  filter(pheromone %in% c(1, 2)) |> 
  group_by(row, col) |> 
  filter(n() == 2) |> 
  filter(mu == max(mu)) |> 
  select(mu, row, col, genotype2) |> 
  left_join(pheromone_proxy, by = join_by(row, col))

plt_prox <- d_proxy |> ggplot() +
  geom_point(aes(x=pheromone_proxy, y=mu, color=genotype2), size = 4) +
  geom_line(aes(x=pheromone_proxy, y=mu, color=genotype2), size = 2) +
  theme_minimal()

# plotly::ggplotly(plt_prox)
plt_prox
```


##### Mixture Model Tests

```{r}
d <- tags_cfp |> 
  filter(tag == "bud") |> 
  filter(cell == "cfp") |> 
  left_join(pdata) |> 
  # filter(strain == 5994, pheromone == 1) |> 
  filter(strain == 6108, pheromone == 1)

ggplot(d) + geom_histogram(aes(t.frame))

x <- d$t.frame
```

###### mclust

Mezclas gaussianas, con inicializacion basada en clustering jerárquico.

```{r}
library(mclust)

BIC <- mclust::mclustBIC(x, G = 1:2, modelNames = "V")

mod1 <- mclust::Mclust(x, x = BIC)

# g_best <- BIC[,1] |> which.min()
# mod1 <- mclust::Mclust(data = x, G = g_best, modelNames = "V")

# Optimal number of mixture components.
mod1$G

# Estimated parameters
mod1$parameters
```

###### mixR

Conclusion: esto al menos recupera los parámetros de las distribuciones originales (flexmix no lo hace).

El problema que tiene es que con "pocos" datos falla completamente.

```{r}
# Selecting the best g for Normal mixture model
s_normal <- mixR::select(c(x, x), ncomp = 1:2)
plot(s_normal)

which_best <- which(s_normal$best == "*")
ncomp = s_normal$ncomp[which_best]
equal_var = s_normal$equal.var[which_best]

mod_normal <- mixR::mixfit(x = x, ncomp = ncomp)
mod_normal
```

mixR con gamma:

```{r}
# Simulate data with a low mean component (near 0) and a higher mean component
mean1 <- 1
sd1 <- 3
mean2 <- 10
sd2 <- 3

n <- 30

shape1 <- (mean1/sd1)^2
rate1 <- mean1/(sd1^2)
shape2 <- (mean2/sd2)^2
rate2 <- mean2/(sd2^2)

data <- c(rgamma(n = n / 2, shape = shape1, rate = rate1), 
          rgamma(n = n / 2, shape = shape2, rate = rate2))

ggplot() + geom_histogram(aes(x=data), binwidth = 1)

c(shape=shape1, rate=rate1)
c(shape=shape2, rate=rate2)
```


```{r}
mod_normal <- mixR::mixfit(x = data, ncomp = 2, family = "gamma")

mod_normal[c("alpha", "lambda")]
```

###### flexmix

Conclusion: parecia piola, pero la verdad es que no recupera los parametros de las distribuciones originales al simular.

flexmix: <https://chatgpt.com/c/67325580-32c0-800f-8023-1e5012aef33a>

```{r}
# install.packages("flexmix")

# Simulate some example data for illustration
set.seed(123)
n <- 500
# Simulate data with a low mean component (near 0) and a higher mean component
data <- c(rpois(n / 2, lambda = 1), rpois(n / 2, lambda = 10))

hist(data)
```

```{r}
family <- "poisson"
```

```{r}
# Fit a 2-component Poisson mixture model
mix_model_2 <- flexmix::flexmix(data ~ 1, k = 2, model = flexmix::FLXMRglm(family = family))

# Print model summary
summary(mix_model_2)

# Extract parameters of the components (lambdas)
flexmix::parameters(mix_model_2)
```

```{r}
# Fit a 1-component model
mix_model_1 <- flexmix::flexmix(data ~ 1, k = 1, model = flexmix::FLXMRglm(family = family))

# Compare models using BIC
BIC(mix_model_2, mix_model_1)
```

```{r}
library(flexmix)
plot(mix_model_2, which = "histogram")
```

```{r}
lambdas <- flexmix::parameters(mix_model_2)
# x <- seq(from=0, to=30, length.out=100)
x <- 0:15
ggplot() +
  geom_line(aes(x=x, y=dpois(x, lambda = lambdas[1], log = F))) +
  geom_line(aes(x=x, y=dpois(x, lambda = lambdas[2], log = F)))
```

```{r}
i <- 1
mix_model_cfp_p1 <- data_cfp_p1_split |> 
  seq_along() |>
  lapply(function(i){
    d <- data_cfp_p1_split[[i]]
    # hist(d$t.frame)
    mix_model_2 <- flexmix::flexmix(d$t.frame ~ 1, k = 2, model = flexmix::FLXMRglm(family = "poisson"))
    mix_model_1 <- flexmix::flexmix(d$t.frame ~ 1, k = 1, model = flexmix::FLXMRglm(family = "poisson"))
    model2_better <- BIC(mix_model_2, mix_model_1)$BIC |> diff() > 2
    if(model2_better)
      lambdas <- flexmix::parameters(mix_model_2)
    else
      lambdas <- c(flexmix::parameters(mix_model_1), NA)
    r <- lambdas |> setNames(c("comp1", "comp2")) |> c(pos=d$pos[1])
    return(r)
  }) |> 
  bind_rows()

mix_model_cfp_p1
```

flexmix con gamma:

```{r}
# Simulate data with a low mean component (near 0) and a higher mean component
mean1 <- 1
sd1 <- 3

mean2 <- 10
sd2 <- 3

n <- 500

shape1 <- (mean1/sd1)^2
rate1 <- mean1/(sd1^2)
shape2 <- (mean2/sd2)^2
rate2 <- mean2/(sd2^2)

data <- c(rgamma(n = n / 2, shape = shape1, rate = rate1), 
          rgamma(n = n / 2, shape = shape2, rate = rate2))

c(shape=shape1, rate=rate1)
c(shape=shape2, rate=rate2)
```


```{r}
x <- seq(from=0.1, to=30, length.out=1000)
ggplot() + 
  geom_histogram(aes(x=data), binwidth = 1) +
  geom_line(aes(x=x, y=dgamma(x, shape = shape1, rate = rate1)*300)) +
  geom_line(aes(x=x, y=dgamma(x, shape = shape2, rate = rate2)*300))
```


```{r}
# Set initial clusters (randomly or based on prior knowledge)
initial_clusters <- ifelse(data > median(data), 1, 2)

family <- "Gamma"
mix_model_2 <- flexmix::flexmix(data ~ 1, k = 2, model = flexmix::FLXMRglm(family = family), cluster = initial_clusters)
mix_model_1 <- flexmix::flexmix(data ~ 1, k = 1, model = flexmix::FLXMRglm(family = family))

params <- flexmix::parameters(mix_model_2)
rates <- params[1,]
shapes <- params[2,]

rate0 = flexmix::parameters(mix_model_1)[1,]
shape0 = flexmix::parameters(mix_model_1)[2,]

print(params)
```

```{r}
# x <- seq(from=0, to=30, length.out=100)
# x <- seq(from=0.1, to=10, length.out=1000)
ggplot() +
  geom_line(aes(x=x, y=dgamma(x, shape = shapes[1], rate = rates[1]))) +
  geom_line(aes(x=x, y=dgamma(x, shape = shapes[2], rate = rates[2]))) +
  geom_line(aes(x=x, y=dgamma(x, shape = shape0, rate = rate0), color="gray"))
  ggtitle(params)
```

```{r}
n <- 10000
data2 <- c(rgamma(n = n / 2, shape = shapes[1], rate = rates[1]), 
           rgamma(n = n / 2, shape = shapes[2], rate = rates[2]))

ggplot() + geom_histogram(aes(x=data2), binwidth = 1)
```

###### rstan

Conclusion: demasido overkill, esto no parece estar hecho para pocos datos...

stan: <https://chatgpt.com/share/6732679e-c9c8-800f-b04b-f36e81d85b9d>

```{r}
# install.packages("rstan")
library(rstan)
```

```{r}
# Save this Stan model as a string
stan_model_code_poisson <- "
data {
  int<lower=1> N;           // Number of observations
  int<lower=0> y[N];        // Observed counts
  int<lower=1> K;           // Number of mixture components (2 in this case)
}
parameters {
  real<lower=0> lambda[K];  // Rate parameters for each component
  simplex[K] theta;         // Mixture weights (must sum to 1)
}
model {
  // Priors for lambda and theta
  lambda ~ exponential(1);       // Prior for lambda (adjust if needed)
  theta ~ dirichlet(rep_vector(1.0, K)); // Prior for mixture weights

  // Mixture model
  for (n in 1:N) {
    vector[K] log_component;
    for (k in 1:K) {
      log_component[k] = log(theta[k]) + poisson_lpmf(y[n] | lambda[k]);
    }
    target += log_sum_exp(log_component);
  }
}
generated quantities {
  real bic;
  bic = -2 * target() + log(N) * (K - 1 + K); // BIC calculation
}
"

# Save this Stan model as a string
stan_model_code_gamma <- "
data {
  int<lower=1> N;             // Number of observations
  real<lower=0> y[N];         // Observed positive counts (continuous data)
  int<lower=1> K;             // Number of mixture components (2 in this case)
}
parameters {
  real<lower=0> alpha[K];     // Shape parameters for each Gamma component
  real<lower=0> beta[K];      // Rate parameters for each Gamma component
  simplex[K] theta;           // Mixture weights (must sum to 1)
}
transformed parameters {
  real log_lik;               // Log-likelihood accumulator
  log_lik = 0;                // Initialize log-likelihood

  // Mixture model: calculate log-likelihood
  for (n in 1:N) {
    vector[K] log_component;
    for (k in 1:K) {
      log_component[k] = log(theta[k]) + gamma_lpdf(y[n] | alpha[k], beta[k]);
    }
    log_lik += log_sum_exp(log_component); // Accumulate log-likelihood
  }
}
model {
  // Priors for alpha, beta, and theta
  alpha ~ normal(2, 1);       // Prior for shape parameters
  beta ~ normal(0.5, 0.5);    // Prior for rate parameters (adjust if needed)
  theta ~ dirichlet(rep_vector(1.0, K)); // Prior for mixture weights
}
generated quantities {
  real bic;
  bic = -2 * log_lik + log(N) * (2 * K + K - 1); // BIC calculation
}
"

```

```{r}
hist(data)
```

```{r}
stan_model_code <- stan_model_code_poisson
stan_model_code <- stan_model_code_gamma

# Prepare data for Stan
data_list <- list(
  N = length(data),  # Number of observations
  y = data + 0.1,          # Observed data vector (continuous)
  K = 2              # Number of components
)

# Compile and fit the model
fit <- stan(model_code = stan_model_code, data = data_list, 
            iter = 500, chains = 4, seed = 123)
```

```{r}
# Print a summary of the posterior distributions
print(fit, pars = c("alpha", "beta", "theta", "bic"))

# Extract BIC
bic <- extract(fit, pars = "bic")$bic
mean_bic <- mean(bic)
print(mean_bic)
```

```{r}
# Extract posterior samples
posterior_samples <- extract(fit)

# Plot posterior distribution for lambda[1] and lambda[2]
library(ggplot2)

# For lambda[1]
ggplot(data.frame(lambda1 = posterior_samples$lambda[, 1]), aes(lambda1)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Posterior distribution of lambda[1]")

# For lambda[2]
ggplot(data.frame(lambda2 = posterior_samples$lambda[, 2]), aes(lambda2)) +
  geom_density(fill = "red", alpha = 0.5) +
  labs(title = "Posterior distribution of lambda[2]")
```


```{r}
# Extract the posterior samples for all parameters
posterior_samples <- extract(fit)

# View the names of the extracted parameters
par_means <- posterior_samples |> lapply(colMeans)
```



